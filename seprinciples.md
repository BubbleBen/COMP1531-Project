# Software Engineering Principles
With our new knowledge of software engineering principles such as Don't Repeat Yourself (DRY), Keep It Simple Stupid (KISS) and more, when we were required to refactor and add to our code, we made some extra changes to adhere to these to practice better software engineering methods. By practicing these methods we made our code 'smell less' meaning it was more rigid, less fragile, more mobile, and removed lots of needless complexity. For example, when we incorporated some more useful components to our class, such as permission flags or a list of channels the user is in, which made the code easier to change, as we did not need to read through all the code and change a few lines here and there.  

We also attempted to have uniform convention of variable names, function names and comments in order to increase readability, which was a major issue for us in iteration 2. One example of a minor fix we made, was changing all the class definitions to starting with a capital letter, as this made using the lower case version in for loops much less frustrating.  

However, the most significant change we made was the separation of our functions from our route handler, which was from what we saw assumed in iteration 2, but we had missed. This made our code much easier to read but more importantly test and use the code in different projects in the future. Overall the principles were adhered via the following ways:

## Don't Repeat Yourself (DRY)
We implemented more helper functions in our helper_functions.py file. The helper functions were refined to only have one purpose (as given in their name), and improved the current ones by removing repetition and unnecessary flags. By doing this, we minimised repetition and thus had the code be more succinct. Some of the helper functions implemented were:

* user_from_token() - takes in a token, returns a User object
* check_channel_member() - takes in a Channel object and u_id, and returns True or False depending on whether the user is in the channel
* find_channel() - takes in a channel_id, returns a Channel object

We also found that when another team member needed a certain helper function, if we checked the helper_functions.py file more often than not someone else had already wrote it, allowing us to reuse that code and lower the time taken to complete the project. This not only made programming easier, but it also made it easier to read for other members of our team who needed to use those functions.  

Additionally, our code was refactored in order to utilise pre-existing functions that had already been written by other teammates. Instead of writing functions to perform the same tasks as other functions, we simply included the functions used from other teammates' code in our own functions. An example of this is in standup_send - which performs much the same task as message_send, but only in standups. Instead of writing a completely new message function for standup_send, we simply changed what needed to be changed, and called message_send inside standup_send. By doing this, we avoided needless repetition, and made our code far easier to read and use.

## Keep It Simple Stupid (KISS)
Previously, in iteration 2, we as a team was using the uuid4 module to generate random numbers for each id, whether it was user_id or message_id etc. This was unrequired complexity that we are adding, and found it lead to errors with the numbers being too large when we try to search for a certain id. Therefore, instead we removed the use of this for ids, and instead just kept track of how many messages, channels or users there were, and used that tracked number as the ids. This is not an issue as overlaps will never occur, and even if a certain message is deleted, the counter keeps incrementing and not issues will occur.

## You Aren't Gonna Need It (YAGNI)
Fortunately, this was one of the design principles that we as a group were adhering to without explicitly knowing so. At no point did we start building lower level functions until we fully understood the specifications and the purpose of each function. For example, our helper functions were not written until after we realised that certain aspects of our code were repeating themselves. We also always began writing the higher level function first. This not only lead to minimising waste of time (as we didn't write any code we didn't need) but also minimised frustration as by doing so, we never ran into an issue where once we began writing we realised too late the code was not meetings the requirements anymore.  

Furthermore, instead of using "from ____ import [asterisk]" which imports all functions in that module into the file, we decided to list all the functions out one by one. This reduced our chances of error and we may have had overlapping names, but also ensures we didn't have any excess that we didn't need.  

## Single Responsibility Principle (SRP)
When reading over our code from iteration 2, we discovered that a lot of the functions, especially the more involved ones, were performing multiple roles at once. We refactored the code so that the majority of it would perform only one function - for example, our helper_functions, in addition to being under the DRY principle, were also added to ensure that parts of our code only had a single responsibility.  

One example of a larger function being split up into multiple parts was the standup_start function. There are multiple parts to the standup process - starting the standup, sending the messages inside the standup, ending the standup, and sending the compiled list of messages after the standup has finished. The way we decided to implement this used the single responsibility principle: standup_start() only started the standup, and called standup_active() to keep track of the current standup. standup_send() only sent messages to the channel while the standup was active. An additional function, standup_end(), was created, in order to take care of the process of ending and sending the summarised message after the standup had finished.
